# -*- coding: utf-8 -*-
"""performance.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/162rzCRxuCOZeFAZu8BUYFzAJX4qf2CCf
"""

# Training progress bar
!pip install -q qqdm
import math
import cv2
import random
import numpy as np
import torch
from torch import nn
from torch.utils.data import DataLoader, RandomSampler, SequentialSampler, TensorDataset, BatchSampler
import torchvision.transforms as transforms
import torch.nn.functional as F
from torch.autograd import Variable
import torchvision.models as models
from torch.optim import Adam, AdamW
from qqdm import qqdm, format_str
import pandas as pd

## Don't change the below two functions (compute_PSNR, compute_SSIM)!!
def compute_PSNR(img1, img2): ## 請輸入範圍在0~1的圖片!!!
    # Compute Peak Signal to Noise Ratio (PSNR) function
    # img1 and img2 > [0, 1] 
    
    img1 = torch.as_tensor(img1, dtype=torch.float32)# In tensor format!!
    img2 = torch.as_tensor(img2, dtype=torch.float32)
    mse = torch.mean((img1 - img2) ** 2)
    return 20 * torch.log10(1 / torch.sqrt(mse))

def compute_SSIM(img1, img2): ## 請輸入範圍在0~1的圖片!!!
    # Compute Structure Similarity (SSIM) function
    # img1 and img2 > [0, 1]
    C1 = (0.01 * 1) ** 2
    C2 = (0.03 * 1) ** 2

    img1 = img1.astype(np.float64)
    img2 = img2.astype(np.float64)
    kernel = cv2.getGaussianKernel(11, 1.5)
    window = np.outer(kernel, kernel.transpose())

    mu1 = cv2.filter2D(img1, -1, window)[5:-5, 5:-5]  # valid
    mu2 = cv2.filter2D(img2, -1, window)[5:-5, 5:-5]
    mu1_sq = mu1**2
    mu2_sq = mu2**2
    mu1_mu2 = mu1 * mu2
    sigma1_sq = cv2.filter2D(img1**2, -1, window)[5:-5, 5:-5] - mu1_sq
    sigma2_sq = cv2.filter2D(img2**2, -1, window)[5:-5, 5:-5] - mu2_sq
    sigma12 = cv2.filter2D(img1 * img2, -1, window)[5:-5, 5:-5] - mu1_mu2

    ssim_map = ((2 * mu1_mu2 + C1) * (2 * sigma12 + C2)) / ((mu1_sq + mu2_sq + C1) * (sigma1_sq + sigma2_sq + C2))
    return ssim_map.mean()

# AE model
class conv_autoencoder(nn.Module):
    def __init__(self):
        super(conv_autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Conv2d(3, 12, 3, stride=1, padding=1),         
            nn.ReLU(),
            nn.Conv2d(12, 24, 3, stride=1, padding=1),        
            nn.ReLU(),
			      nn.Conv2d(24, 48, 3, stride=1, padding=1),         
            nn.ReLU(),
        )
        self.decoder = nn.Sequential(
			      nn.ConvTranspose2d(48, 24, 3, stride=1, padding=1),
            nn.ReLU(),
			      nn.ConvTranspose2d(24, 12, 3, stride=1, padding=1), 
            nn.ReLU(),
            nn.ConvTranspose2d(12, 3, 3, stride=1, padding=1),
            nn.Tanh(),
        )

    def forward(self, x):
        x = self.encoder(x)
        x = self.decoder(x)
        return x

# VAE model
class VAE(nn.Module):
    def __init__(self):
        super(VAE, self).__init__()
        self.encoder = nn.Sequential(
            nn.Conv2d(3, 12, 3, stride=1, padding=1),          
            nn.ReLU(), 
            nn.Conv2d(12, 24, 3, stride=1, padding=1),           
            nn.ReLU(), 
            nn.Conv2d(24, 48, 3, stride=1, padding=1),           
            nn.ReLU()
        )
        self.enc_out_1 = nn.Sequential(
            nn.Conv2d(48, 96, 3, stride=1, padding=1),  
            nn.ReLU(),
        )
        self.enc_out_2 = nn.Sequential(
            nn.Conv2d(48, 96, 3, stride=1, padding=1),
            nn.ReLU(),
        )
        self.decoder = nn.Sequential(
            nn.Conv2d(96, 48, 3, stride=1, padding=1),           
            nn.ReLU(), 
            nn.ConvTranspose2d(48, 24, 3, stride=1, padding=1), 
            nn.ReLU(),
			      nn.ConvTranspose2d(24, 12, 3, stride=1, padding=1), 
            nn.ReLU(),
            nn.ConvTranspose2d(12, 3, 3, stride=1, padding=1), 
            nn.Tanh(),
        )

    def encode(self, x):
        h1 = self.encoder(x)
        return self.enc_out_1(h1), self.enc_out_2(h1)

    def reparametrize(self, mu, logvar):
        std = logvar.mul(0.5).exp_()
        if torch.cuda.is_available():
            eps = torch.cuda.FloatTensor(std.size()).normal_()
        else:
            eps = torch.FloatTensor(std.size()).normal_()
        eps = Variable(eps)
        return eps.mul(std).add_(mu)

    def decode(self, z):
        return self.decoder(z)

    def forward(self, x):
        mu, logvar = self.encode(x)
        z = self.reparametrize(mu, logvar)
        return self.decode(z), mu, logvar


# load in original image
original_image = np.load("eye/data.npy")

# load in AE & VAE model weight
best_model_AE = torch.load("best_model_cnn.pth")
best_model_VAE = torch.load("best_model_vae.pth")

input = torch.from_numpy(original_image*2-1).permute(0,3,1,2).float().cuda()
# compute AE model output
output_image_AE = best_model_AE(input).cpu().permute(0,2,3,1)
output_image_AE = ((output_image_AE+1)/2).detach().numpy()

# compute VAE model output
output_image_VAE = best_model_VAE(input)[0].cpu().permute(0,2,3,1)
output_image_VAE = ((output_image_VAE+1)/2).detach().numpy()

# AE model performance
print("PSNR score (AE) :",compute_PSNR(original_image,output_image_AE).item())
ssim_AE = []
for i in range(1476):
  ssim_AE.append(compute_SSIM(original_image[i],output_image_AE[i]))
print("SSIM score (AE) :",sum(ssim_AE)/1476)

# VAE model performance
print("PSNR score (VAE) :",compute_PSNR(original_image,output_image_VAE).item())
ssim_VAE = []
for i in range(1476):
  ssim_VAE.append(compute_SSIM(original_image[i],output_image_VAE[i]))
print("SSIM score (VAE) :",sum(ssim_VAE)/1476)