# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14DopdMZ2sG_pT3fav85k5sDjawx7wTaK
"""

import h5py
import numpy as np
import torch
from sklearn.preprocessing import OneHotEncoder
import torch.nn as nn

def cal_accuracy(prediction, label):
    ''' Calculate Accuracy, please don't modify this part
        Args:
            prediction (with dimension N): Predicted Value
            label  (with dimension N): Label
        Returns:
            accuracy:　Accuracy
    '''

    accuracy = 0
    number_of_data = len(prediction)
    for i in range(number_of_data):
        accuracy += float(prediction[i] == label[i])
    accuracy = (accuracy / number_of_data) * 100

    return accuracy


# CNN model
class Classifier(nn.Module):
    def __init__(self):
        super(Classifier, self).__init__()
        # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)
        # torch.nn.MaxPool2d(kernel_size, stride, padding)
        # input 維度 [3, 64, 64]
        self.cnn = nn.Sequential(
            nn.Conv2d(3, 64, 3, 1, 1),  # [64, 64, 64]
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),      # [64, 32, 32]

            nn.Conv2d(64, 128, 3, 1, 1), # [128, 32, 32]
            nn.BatchNorm2d(128),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),      # [128, 16, 16]

            nn.Conv2d(128, 256, 3, 1, 1), # [256, 16, 16]
            nn.BatchNorm2d(256),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),      # [256, 8, 8]

            nn.Conv2d(256, 512, 3, 1, 1), # [512, 8, 8]
            nn.BatchNorm2d(512),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),       # [512, 4, 4]

            nn.Conv2d(512, 1024, 3, 1, 1), # [1024, 4, 4]
            nn.BatchNorm2d(1024),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),       # [1024, 2, 2]

            nn.Conv2d(1024, 2048, 3, 1, 1), # [2048, 2, 2]
            nn.BatchNorm2d(2048),
            nn.ReLU(),
            nn.MaxPool2d(2, 2, 0),       # [2048, 1, 1]
        )
        self.fc = nn.Sequential(
            nn.Linear(2048*1*1, 1024),
            nn.ReLU(),
            nn.Linear(1024, 512),
            nn.ReLU(),
            nn.Linear(512, 6)
        )

    def forward(self, x):
        out = self.cnn(x)
        out = out.contiguous().view(out.size()[0], -1)
        return self.fc(out)


# Load in testing image and label
# hf_test = h5py.File("/content/drive/MyDrive/DeepLearning/Homework/HW3/Dataset/Signs_Data_Testing.h5", 'r')
hf_test = h5py.File("Dataset/Signs_Data_Testing.h5", 'r')
test_image = np.array(hf_test["test_set_x"])
test_image = torch.from_numpy(test_image).permute(0,3,1,2)
test_image = 2*(test_image/255) - 1  # mapping to [-1,1]
test_label = np.array(hf_test["test_set_y"])

# Load final model
# model = torch.load("/content/drive/MyDrive/DeepLearning/Homework/HW3/model_weights.pth")
model = torch.load("model_weights.pth")

# Compute predicted probability
pred_prob = model(test_image.cuda()).cpu().detach().numpy()
pred_label = np.argmax(pred_prob, axis=1) # predicted label

# Check prediction performance
test_acc = cal_accuracy(pred_label, test_label)
print(f"Test accuracy : {test_acc:.2f}%")